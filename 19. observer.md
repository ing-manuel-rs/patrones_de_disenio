# **Observer**

El patr贸n Observer establece una relaci贸n de uno a muchos entre objetos:

Cuando un objeto cambia su estado, notifica autom谩ticamente a todos sus observadores para que reaccionen de forma adecuada.

Esto permite una arquitectura desacoplada, donde los objetos pueden interactuar sin conocerse entre s铆 directamente.



## Met谩fora real

Imagina que est谩s suscrito a un canal de YouTube:
- El canal es el **Sujeto**.
- T煤 eres el **Observador**.
- Cuando el canal publica un nuevo video, recibes una notificaci贸n autom谩ticamente.
Eso es el patr贸n Observer en acci贸n



## Ejemplo en JavaScript: Sistema de notificaciones

Clase Sujeto
```js
class Sujeto {
  constructor() {
    this.observadores = [];
  }

  adjuntar(observador) {
    this.observadores.push(observador);
  }

  remover(observador) {
    this.observadores = this.observadores.filter(o => o !== observador);
  }

  notificar(data) {
    this.observadores.forEach(obs => obs.actualizar(data));
  }
}
```

Observadores
```js
class ObservadorConsola {
  actualizar(data) {
    console.log("Consola recibi贸:", data);
  }
}

class ObservadorEmail {
  actualizar(data) {
    console.log(" Enviando email con:", data);
  }
}
```

Uso
```js
const canal = new Sujeto();

const obs1 = new ObservadorConsola();
const obs2 = new ObservadorEmail();

canal.adjuntar(obs1);
canal.adjuntar(obs2);

canal.notificar("隆Nuevo video publicado!");
```
Ambos observadores reciben la notificaci贸n autom谩ticamente.



## Flujo del patr贸n Observer

1. El **sujeto** (publisher) mantiene una lista de observadores (subscribers).
2. Cuando ocurre un cambio (nuevo estado, evento, etc.), el sujeto ejecuta `.notificar()`.
3. Todos los observadores ejecutan su m茅todo `.actualizar()` (reacci贸n individual).



## 驴Cu谩ndo usar el patr贸n Observer?

| Situaci贸n                                           | Ejemplo                                |
| --------------------------------------------------- | -------------------------------------- |
| Cambios de estado deben reflejarse en otros objetos | Actualizar m煤ltiples componentes en UI |
| Programaci贸n basada en eventos                      | Clics, entradas de usuario, sockets    |
| Sistemas de suscripci贸n o notificaci贸n              | Pub/Sub, sistemas de mensajer铆a        |
| Comunicaci贸n entre componentes desacoplados         | React, Redux, Vue, RxJS                |



## Ejemplos reales

|Tecnolog铆a|Uso de Observer|
|---|---|
|React|`useEffect`, `state`, `context`, `useSubscribe()`|
|RxJS|Observables y operadores (`.subscribe()`)|
|Vue.js|Sistema reactividad / binding bidireccional|
|Firebase|`onSnapshot()`, `onValue()` para escuchar cambios en tiempo real|
|Web APIs|`addEventListener` en DOM|



## Ventajas

| Ventaja             | Explicaci贸n                                       |
| ------------------- | ------------------------------------------------- |
| Bajo acoplamiento   | Sujeto y observadores no se conocen directamente  |
| Alta escalabilidad  | Puedes a帽adir observadores sin cambiar la l贸gica  |
| Reacci贸n autom谩tica | Los cambios se propagan de inmediato y f谩cilmente |



## Desventajas

|Desventaja|Explicaci贸n|
|---|---|
|Dif铆cil de depurar|Muchos observadores pueden ocultar el origen del cambio|
|Posibles fugas de memoria|Si no eliminas observadores, se quedan en memoria|
|Orden no garantizado|No sabes en qu茅 orden ser谩n llamados los observers|