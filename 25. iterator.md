# **Iterator**

Es un patr√≥n de comportamiento que:
- Permite recorrer colecciones de manera uniforme.
- Desacopla la l√≥gica de iteraci√≥n de la estructura de la colecci√≥n.
- Soporta m√∫ltiples tipos de recorrido sin modificar la colecci√≥n original.
En JavaScript ya usamos iteradores cada vez que usamos `for...of`, `Array.prototype.map()`, `next()` en generadores, etc.



## Met√°fora real

Piensa en una biblioteca:
- Cada estanter√≠a (estructura) tiene muchos libros (elementos).
- El bibliotecario (iterador) sabe c√≥mo recorrer la estanter√≠a sin que t√∫ sepas c√≥mo est√° organizada (por autor, g√©nero, fecha‚Ä¶).
- T√∫ solo necesitas pedir: ‚Äúdame el siguiente‚Äù.



## Ejemplo en JavaScript: crear un iterador manual

Crear una colecci√≥n personalizada
```js
class ColeccionNombres {
  constructor() {
    this.nombres = [];
  }

  agregar(nombre) {
    this.nombres.push(nombre);
  }

  crearIterador() {
    return new IteradorNombres(this.nombres);
  }
}
```

Crear el iterador
```js
class IteradorNombres {
  constructor(nombres) {
    this.nombres = nombres;
    this.indice = 0;
  }

  hasNext() {
    return this.indice < this.nombres.length;
  }

  next() {
    return this.nombres[this.indice++];
  }
}
```

Uso
```js
const coleccion = new ColeccionNombres();
coleccion.agregar("Ana");
coleccion.agregar("Luis");
coleccion.agregar("Marta");

const iterador = coleccion.crearIterador();

while (iterador.hasNext()) {
  console.log("üì¶", iterador.next());
}
```

Output
```js
üì¶ Ana
üì¶ Luis
üì¶ Marta
```



## El protocolo de iteraci√≥n en JavaScript

En JavaScript moderno, puedes hacer que tus objetos sean iterables usando el m√©todo `Symbol.iterator`.

Ejemplo: creando un iterable personalizado
```js
const dias = {
  lista: ["Lunes", "Martes", "Mi√©rcoles"],
  [Symbol.iterator]() {
    let i = 0;
    const self = this;
    return {
      next() {
        return {
          value: self.lista[i],
          done: i++ >= self.lista.length
        };
      }
    };
  }
};

for (const dia of dias) {
  console.log("üìÖ", dia);
}
```



## ¬øCu√°ndo usar el patr√≥n Iterator?

| Situaci√≥n                                | Ejemplo                                  |
| ---------------------------------------- | ---------------------------------------- |
| Quieres recorrer una colecci√≥n           | Arrays, listas, conjuntos, √°rboles       |
| Deseas ocultar la implementaci√≥n         | Lista enlazada, √°rbol binario, etc.      |
| Requieres diferentes formas de recorrido | De atr√°s hacia adelante, filtrado, etc.  |
| Colecci√≥n puede cambiar                  | Mantienes la interfaz de iteraci√≥n igual |



## Ejemplos reales del patr√≥n Iterator

| Contexto           | Iteradores usados                                      |
| ------------------ | ------------------------------------------------------ |
| JavaScript moderno | `for...of`, `[...spread]`, `Array.from()`, generadores |
| Bases de datos     | Recorrer resultados de consultas                       |
| √Årbol DOM          | Recorrer nodos con iteradores personalizados           |
| Archivos grandes   | Leer l√≠neas/bytes sin cargar todo en memoria           |



## Ventajas

| Ventaja                                | Explicaci√≥n                                         |
| -------------------------------------- | --------------------------------------------------- |
| Iteraci√≥n uniforme                     | Puedes usar la misma l√≥gica con cualquier colecci√≥n |
| Oculta la estructura interna           | No importa si es lista, set, √°rbol, etc.            |
| Facilita recorrido personalizado       | Recorridos condicionales, reversos, filtrados       |
| Compatible con el protocolo `for...of` | En JavaScript moderno                               |



## Desventajas

| Desventaja                        | Explicaci√≥n                                    |
| --------------------------------- | ---------------------------------------------- |
| Puede parecer redundante          | Si la colecci√≥n ya es iterable nativamente     |
| Complejidad innecesaria           | Para estructuras simples, puede ser "overkill" |
| No siempre soporta modificaciones | Si la colecci√≥n cambia durante el recorrido    |
