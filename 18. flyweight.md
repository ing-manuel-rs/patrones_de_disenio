# **Flyweight**

El patr√≥n Flyweight es un patr√≥n estructural que se utiliza para compartir instancias comunes entre muchos objetos, evitando duplicaciones innecesarias.

La idea es dividir el estado del objeto en dos partes:
- **Estado interno:** compartido y reutilizable.
- **Estado externo:** proporcionado por el cliente cuando se usa el objeto.

Este patr√≥n es especialmente √∫til cuando tienes muchas instancias que son id√©nticas o muy similares.



## Met√°fora real

Piensa en una tipograf√≠a de texto:
- Cada letra en pantalla podr√≠a ser un objeto (¬°millones en un documento largo!).
- En vez de crear una instancia por cada letra, el sistema usa una sola instancia por letra del alfabeto, y solo cambia su posici√≥n, color, etc.

üÖ∞Ô∏è ‚Üí Solo necesitas una instancia para "A, no mil copias.



## Ejemplo en JavaScript: √Årboles en un juego

Supongamos que est√°s desarrollando un juego con 10,000 √°rboles. Muchos tienen el mismo tipo, color y textura.

Clase Flyweight (estado compartido)
```js
class TipoArbol {
  constructor(nombre, color, textura) {
    this.nombre = nombre;
    this.color = color;
    this.textura = textura;
  }

  mostrar(x, y) {
    console.log(`üå≥ √Årbol [${this.nombre}] en (${x}, ${y}) con color ${this.color}`);
  }
}
```

FlyweightFactory (gestor de instancias compartidas)
```js
class FabricaTiposArbol {
  constructor() {
    this.tipos = {};
  }

  obtener(nombre, color, textura) {
    const clave = `${nombre}_${color}_${textura}`;
    if (!this.tipos[clave]) {
      console.log(`üå± Creando nuevo tipo de √°rbol: ${clave}`);
      this.tipos[clave] = new TipoArbol(nombre, color, textura);
    }
    return this.tipos[clave];
  }
}
```

√Årbol (objeto con estado externo)
```js
class Arbol {
  constructor(x, y, tipo) {
    this.x = x;
    this.y = y;
    this.tipo = tipo; // Compartido
  }

  mostrar() {
    this.tipo.mostrar(this.x, this.y);
  }
}
```

Uso
```js
const fabrica = new FabricaTiposArbol();
const bosque = [];

for (let i = 0; i < 10000; i++) {
  const tipo = fabrica.obtener("Pino", "Verde", "TexturaPino");
  bosque.push(new Arbol(Math.random() * 500, Math.random() * 500, tipo));
}

// Mostrar algunos
bosque[0].mostrar();
bosque[9999].mostrar();
```
Solo se crea una sola instancia de TipoArbol aunque se creen 10,000 √°rboles.



## ¬øQu√© es el estado interno vs externo?

| Tipo de Estado | Ejemplo                       | Qui√©n lo mantiene       |
| -------------- | ----------------------------- | ----------------------- |
| **Interno**    | Tipo de √°rbol, textura, color | Flyweight (compartido)  |
| **Externo**    | Posici√≥n X/Y, altura          | Cliente (por instancia) |



## ¬øCu√°ndo usar Flyweight?

| Situaci√≥n                                 | Ejemplo                                |
| ----------------------------------------- | -------------------------------------- |
| Necesitas **crear millones de objetos**   | Caracteres en pantalla, p√≠xeles, nodos |
| Muchos objetos **tienen datos repetidos** | Iconos, √°rboles, part√≠culas, letras    |
| Recursos limitados (memoria, rendimiento) | Juegos, renderizaci√≥n gr√°fica, IDEs    |



## Ejemplos reales

|Caso real|Aplicaci√≥n de Flyweight|
|---|---|
|Navegadores web|Una sola instancia de cada letra, estilo, color|
|IDEs (VSCode, etc.)|Tokens de sintaxis (palabras clave, colores)|
|Juegos 2D/3D|√Årboles, rocas, enemigos con el mismo modelo|
|Render de mapas|Baldosas, √≠conos de edificios, caminos repetitivos|
|Emuladores de texto|Letras como flyweights + posici√≥n como estado externo|



## Ventajas

| Ventaja                         | Explicaci√≥n                                           |
| ------------------------------- | ----------------------------------------------------- |
| Ahorro de memoria               | Evita duplicaci√≥n de objetos con datos repetidos      |
| Mejora del rendimiento          | Menos objetos, menos carga en el recolector de basura |
| Separaci√≥n de responsabilidades | Reparte el estado externo e interno de forma limpia   |



## Desventajas

|Desventaja|Explicaci√≥n|
|---|---|
|Mayor complejidad|El dise√±o requiere cuidado para no mezclar estados|
|Dificultad para mantener|M√°s dif√≠cil de entender para principiantes|
|No siempre es √∫til|Solo conviene cuando hay muchos objetos similares|
